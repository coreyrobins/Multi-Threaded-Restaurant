package cmsc433.p2;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * Validates a simulation
 */
public class Validate {

	public final SimulationEvent event = null;

	private static class InvalidSimulationException extends Exception {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;

		public InvalidSimulationException() { }
	};

	// Helper method for validating the simulation
	private static void check(boolean check,
			String message) throws InvalidSimulationException {
		if (!check) {
			System.err.println("SIMULATION INVALID : "+message);
			throw new Validate.InvalidSimulationException();
		}
	}

	/** 
	 * Validates the given list of events is a valid simulation.
	 * Returns true if the simulation is valid, false otherwise.
	 *
	 * @param events - a list of events generated by the simulation
	 *   in the order they were generated.
	 *
	 * @return whether the simulation was valid or not
	 */
	public static boolean validateSimulation(List<SimulationEvent> events) {
		try {
			check(events.get(0).event == SimulationEvent.EventType.SimulationStarting,
			"Simulation didn't start with initiation event");
			check(events.get(events.size()-1).event == 
				SimulationEvent.EventType.SimulationEnded,
			"Simulation didn't end with termination event");

			/* Write validation code for the following :
				Should not have more eaters than specified --> done
				Should not have more cooks than specified --> done
				The restaurant capacity should not be exceeded --> done
				The capacity of each machine should not be exceeded --> done
				Eater should not receive order until cook completes it --> done
				Eater should not leave restaurant until order is received --> done
				Eater should not place more than one order --> done
				Cook should not work on order before it is placed --> done
			 */

			int numEaters = 0;
			int numCooks = 0;
			int numTables = 0;
			int capacity = 0;

			HashMap<Eater, Integer> currentEatersMap = new HashMap<Eater, Integer>(); // for placing order (orderNum)
			HashMap<Eater, List<Food>> eaterOrdersMap = new HashMap<Eater, List<Food>>(); // for individual foods in order
			HashMap<Eater, Integer> eatersCookedFood = new HashMap<Eater, Integer>(); // for number of foods cooked for eater
			
			ArrayList<Eater> eatersReceivedOrder = new ArrayList<Eater>(); // for eaters that have received order

			HashMap<Cook, Integer> cookOrderProcess = new HashMap<Cook, Integer>(); // which order the cook is processing

			ArrayList<Eater> eatersGoing = new ArrayList<Eater>(); // keep track of eaters who went to restaurant (BEFORE entering)

			// these vars are to make sure the machine is not cooking something that no cook as requested
			int grillRequest = 0;
			int frierRequest = 0;
			int sodaRequest = 0;

			HashMap<Cook, Boolean> grillRequestMap = new HashMap<Cook, Boolean>();
			HashMap<Cook, Boolean> frierRequestMap = new HashMap<Cook, Boolean>();
			HashMap<Cook, Boolean> sodaRequestMap = new HashMap<Cook, Boolean>();

			int currentEaters = 0; // keep track of current number of eaters
			int totalEaters = 0; // keep track of number of eaters that have started

			Eater currentEater = null; // keep this variable to be used in the switch statement

			int currentCooks = 0; // current num of cooks
			int totalCooks = 0; // total number of cooks
			int cooksFinished = 0; // total number of cooks that finished

			int tmp = 0; // tmp var to be used in the switch

			// check capacity of each machine
			int numGrill = 0;
			int numFrier = 0;
			int numSoda = 0;
			
			int totalGrill = 0;
			int totalFrier = 0;
			int totalSoda = 0;
			int machinesDone = 0;

			// keep map of the machines being used at any given time
			HashMap<Machine, Integer> currentMachines = new HashMap<Machine, Integer>();
			Machine grill = new Machine("Grill", null, capacity);
			currentMachines.put(grill, new Integer(0));
			Machine frier = new Machine("Frier", null, capacity);
			currentMachines.put(frier, new Integer(0));
			Machine soda = new Machine("Soda Fountain", null, capacity);
			currentMachines.put(soda, new Integer(0));

			for (SimulationEvent event : events) {

				SimulationEvent.EventType eventType = event.event;

				switch (eventType) {

				case SimulationStarting:
					// initialize the 4 arguments
					numEaters = event.simParams[0];
					numCooks = event.simParams[1];
					numTables = event.simParams[2];
					capacity = event.simParams[3];					

					break;

				case SimulationEnded:

					// make sure total number of cooks started is equal to number of cooks that should have started
					if (totalCooks != numCooks || currentCooks != 0) {
						return false;
					}

					// make sure number of eaters started is equal to the number of eaters that should have started
					if (totalEaters != numEaters || currentEaters != 0) {
						return false;
					}

					// make sure all machines stopped running (and cooked all the food)
					if (numGrill != 0 || numFrier != 0 || numSoda != 0) {
						return false;
					}
					
					// make sure all machines started
					if (totalGrill != 1 || totalFrier != 1 || totalSoda != 1) {
						return false;
					}
					
					// make sure all cooks and machines finished
					if (machinesDone != 3 || cooksFinished != numCooks) {
						return false;
					}

					// only at this point would we return true
					return true;

					/* Eater events */
				case EaterStarting:

					// make sure eater has not entered restaurant or placed order before going to restaurant
					// (and also has never entered the restaurant before)
					if (currentEatersMap.containsKey(event.eater) || eaterOrdersMap.containsKey(event.eater) ||
							eatersCookedFood.containsKey(event.eater)) {
						return false;
					}

					// eater should not start twice
					if (eatersGoing.contains(event.eater)) {
						return false;
					}

					eatersGoing.add(event.eater);

					// increment the total number of eaters and continue
					totalEaters++;

					break;

				case EaterEnteredRestaurant:

					// make sure eater has never entered restaurant before
					if (currentEatersMap.containsKey(event.eater) || eaterOrdersMap.containsKey(event.eater) ||
							eatersCookedFood.containsKey(event.eater)) {
						return false;
					}

					if (!eatersGoing.contains(event.eater)) {
						return false;
					}

					// increment the current number of eaters and continue
					currentEaters++;

					break;

				case EaterPlacedOrder:

					// there should be no mapping on any map to the key
					// (with the key as the event.eater)
					if (currentEatersMap.containsKey(event.eater) || eaterOrdersMap.containsKey(event.eater)
							|| eatersCookedFood.containsKey(event.eater)) {
						return false;
					}
					// put eater onto the currentEatersMap meaning that this eater's order has been added to the queue
					currentEatersMap.put(event.eater, event.eater.getOrderNum());

					// put eater onto the eaterOrdersMap so that new foods may be added
					eaterOrdersMap.put(event.eater, new ArrayList<Food>());

					// put eater onto the eatersCookedFood map so that we have no null pointer later
					eatersCookedFood.put(event.eater, 0);
					break;

				case EaterReceivedOrder:

					// if the order is finished, the currentEatersMap at the key should be -1,
					// the size of the eaterOrdersMap at the key should be 3 (for the 3 foods cooked)
					// and the eatersCookedFood at the key should also be 3 (for the 3 foods cooked)
					if (currentEatersMap.get(event.eater) != -1 || eaterOrdersMap.get(event.eater).size() != 3
							|| eatersCookedFood.get(event.eater) != 3 || eatersReceivedOrder.contains(event.eater)) {
						return false;
					}
					
					eatersReceivedOrder.add(event.eater);
					
					break;

				case EaterLeavingRestaurant:
					// Eater should not leave restaurant until order is received
					// must make sure there is still a mapping for the key in all 3 maps --> if there is not,
					// then we return false
					if (!currentEatersMap.containsKey(event.eater) || !eaterOrdersMap.containsKey(event.eater)
							|| !eatersCookedFood.containsKey(event.eater) || !eatersReceivedOrder.contains(event.eater)) {
						return false;
					}
					// then we must make sure (as in the last case), that the order was finished by both the cook
					// and the machine
					if (currentEatersMap.get(event.eater) != -1 || eaterOrdersMap.get(event.eater).size() != 3
							|| eatersCookedFood.get(event.eater) != 3) {
						return false;
					}

					// decrement the number of current eaters (since this eater has now left)
					currentEaters--;
					break;

					/* Cook Events */
				case CookStarting:
					
					grillRequestMap.put(event.cook, true);
					frierRequestMap.put(event.cook, true);
					sodaRequestMap.put(event.cook, true);
					
					// just increment the total number of cooks
					totalCooks++;
					break;

				case CookReceivedOrder:
					// increment the current number of cooks
					currentCooks++;

					// Cook should not work on order before it is placed
					if (!currentEatersMap.containsValue(event.orderNumber)) {
						return false;
					}

					// make sure cook is not already processing another order
					if (cookOrderProcess.containsKey(event.cook)) {
						return false;
					}

					// put this cook in the map so we know this cook is processing this order
					cookOrderProcess.put(event.cook, event.orderNumber);

					// nothing else to do here

					break;

				case CookStartedFood:
					currentEater = null; // reset val of currentEater

					// find the eater object that we are processing based on the currentEatersMap
					for (Eater e : currentEatersMap.keySet()) {
						if (e.getOrderNum() == event.orderNumber) {
							currentEater = e;
							break;
						}
					}

					// if the currentEater is null, then something is wrong and the eater should not be processed
					// at the moment
					if (currentEater == null) {
						return false;
					}

					// if this food has already been processed by the cook (or another cook), then return false
					// because the same food for the same eater should not be cooked twice
					if (eaterOrdersMap.get(currentEater).contains(event.food)) {
						return false;
					}

					// if the mapping at eatersCookedFood is >= to the size of the eaterOrdersMap list at the mapping,
					// then it means that the machine has cooked for the food before the cook started to cook the food,
					// which is an error
					if (eatersCookedFood.get(currentEater) > eaterOrdersMap.get(currentEater).size()) {
						return false;
					}

					// send over the request to the machine
					if (event.food.toString().equals("burger")) {
						// make sure the cook has not requested the same food twice
						if (grillRequestMap.get(event.cook) == null || grillRequestMap.get(event.cook) == false) {
							return false;
						}
						grillRequest++;
						grillRequestMap.put(event.cook, false);
					} else if (event.food.toString().equals("fries")) {
						if (frierRequestMap.get(event.cook) == null || frierRequestMap.get(event.cook) == false) {
							return false;
						}
						frierRequest++;
						frierRequestMap.put(event.cook, false);
					} else if (event.food.toString().equals("coke")) {
						if (sodaRequestMap.get(event.cook) == null || sodaRequestMap.get(event.cook) == false) {
							return false;
						}
						sodaRequest++;
						sodaRequestMap.put(event.cook, false);
					}

					// if we make it this far though, then add the current food that the cook is cooking
					// to the eaterOrdersMap at the mapping for the current eater
					eaterOrdersMap.get(currentEater).add(event.food);
					break;

				case CookFinishedFood:
					currentEater = null;
					// again, find the currentEater object based on the currentEatersMap
					for (Eater e : currentEatersMap.keySet()) {
						if (e.getOrderNum() == event.orderNumber) {
							currentEater = e;
							break;
						}
					}
					// if currentEater was not found...error
					if (currentEater == null) {
						return false;
					}

					// make sure machine has finished food before cook has finished food
					if (event.food.toString().equals("burger") && 
							(grillRequestMap.get(event.cook) == null || grillRequestMap.get(event.cook) == false)) {
						return false;
					} else if (event.food.toString().equals("fries") && 
							(frierRequestMap.get(event.cook) == null || frierRequestMap.get(event.cook) == false)) {
						return false;
					} else if (event.food.toString().equals("coke") && 
							(sodaRequestMap.get(event.cook) == null || sodaRequestMap.get(event.cook) == false)) {
						return false;
					}

					// get the number of foods that have been cooked for the currentEater, and increment that number
					tmp = eatersCookedFood.get(currentEater);
					eatersCookedFood.remove(currentEater);
					tmp++;
					eatersCookedFood.put(currentEater, tmp);
					break;

				case CookCompletedOrder:
					// decrement the number of cooks currently working
					currentCooks--;
					currentEater = null;
					// find the currentEater object
					for (Eater e : currentEatersMap.keySet()) {
						if (e.getOrderNum() == event.orderNumber) {
							currentEater = e;
							break;
						}
					}
					// make sure current eater not null and that all 3 foods were cooked
					if (currentEater == null) {
						return false;
					}

					if (eatersCookedFood.get(currentEater) != 3) {
						return false;
					}

					// cook is processing wrong order...
					if (cookOrderProcess.get(event.cook) == null || cookOrderProcess.get(event.cook) != event.orderNumber) {
						return false;
					}
					
					if (grillRequestMap.get(event.cook) == null || grillRequestMap.get(event.cook) == false) {
						return false;
					} else if (frierRequestMap.get(event.cook) == null || frierRequestMap.get(event.cook) == false) {
						return false;
					} else if (sodaRequestMap.get(event.cook) == null || sodaRequestMap.get(event.cook) == false) {
						return false;
					}

					cookOrderProcess.remove(event.cook); // remove the cook from the map so he can process another order

					// replace whatever was at currentEater in this map with a -1, signifying that the order
					// has been completed
					currentEatersMap.remove(currentEater);
					currentEatersMap.put(currentEater, -1);

					break;

				case CookEnding:
					cooksFinished++;
					break;

					/* Machine events */
				case MachineStarting:

					// make sure it hasn't started cooking anything
					if (event.machine.name.equals("Grill") && numGrill > 0) {
						return false;
					}
					if (event.machine.name.equals("Frier") && numFrier > 0) {
						return false;
					}
					if (event.machine.name.equals("Soda Fountain") && numSoda > 0) {
						return false;
					}
					
					if (event.machine.name.equals("Grill")) {
						totalGrill++;
					} else if (event.machine.name.equals("Frier")) {
						totalFrier++;
					} else if (event.machine.name.equals("Soda Fountain")) {
						totalSoda++;
					}

					break;

				case MachineStartingFood:

					// make sure each machine is cooking the correct food...
					if (event.machine.food.toString().equals("burger") && !event.machine.name.equals("Grill")) {
						return false;
					} else if (event.machine.food.toString().equals("fries") && !event.machine.name.equals("Frier")) {
						return false;
					} else if (event.machine.food.toString().equals("coke") && !event.machine.name.equals("Soda Fountain")) {
						return false;
					}

					if (event.machine.food.toString().equals("burger")) {
						// make sure a cook has requested a food to be cooked...
						if (grillRequest <= 0) {
							return false;
						}
						numGrill++;
					} else if (event.machine.food.toString().equals("fries")) {
						if (frierRequest <= 0) {
							return false;
						}
						numFrier++;
					} else if (event.machine.food.toString().equals("coke")) {
						if (sodaRequest <= 0) {
							return false;
						}
						numSoda++;
					}
					break;

				case MachineDoneFood:

					// make sure each machine is cooking the correct food...
					if (event.machine.food.toString().equals("burger") && !event.machine.name.equals("Grill")) {
						return false;
					} else if (event.machine.food.toString().equals("fries") && !event.machine.name.equals("Frier")) {
						return false;
					} else if (event.machine.food.toString().equals("coke") && !event.machine.name.equals("Soda Fountain")) {
						return false;
					}

					if (event.machine.food.toString().equals("burger")) {
						// make sure machine has not cooked a food that did not need to be cooked
						// or finished it before starting it
						if (grillRequest <= 0 || numGrill <= 0) {
							return false;
						}
						numGrill--;
						grillRequest--;
						
						// tell cook that the food has been finished by the machine
						for (Cook c : grillRequestMap.keySet()) {
							grillRequestMap.put(c, true);
						}
						
					} else if (event.machine.food.toString().equals("fries")) {
						if (frierRequest <= 0 || numFrier <= 0) {
							return false;
						}
						numFrier--;
						frierRequest--;
						
						for (Cook c : frierRequestMap.keySet()) {
							frierRequestMap.put(c, true);
						}
						
					} else if (event.machine.food.toString().equals("coke")) {
						if (sodaRequest <= 0 || numSoda <= 0) {
							return false;
						}
						numSoda--;
						sodaRequest--;
						
						for (Cook c : sodaRequestMap.keySet()) {
							sodaRequestMap.put(c, true);
						}
						
					}

					break;

				case MachineEnding:

					// make sure it's not still cooking anything
					if (numGrill != 0 || numFrier != 0 || numSoda != 0) {
						return false;
					}

					// make sure no more requests need to be processed
					if (grillRequest != 0 || frierRequest != 0 || sodaRequest != 0) {
						return false;
					}
					
					machinesDone++;

					break;

				default:
					throw new Error("Illegal event; can't be stringified");
				}

				// The restaurant capacity should not be exceeded
				if (currentEaters > numTables) {
					return false;
				}


				// The capacity of each machine should not be exceeded
				if (numGrill > capacity) {
					return false;
				}

				if (numFrier > capacity) {
					return false;
				}

				if (numSoda > capacity) {
					return false;
				}

				// Should not have more eaters than specified
				if (totalEaters > numEaters) {
					return false;
				}

				// Should not have more cooks than specified
				if (totalCooks > numCooks) {
					return false;
				}

			}

			return false;

		} catch (InvalidSimulationException e) {
			return false;
		}
	}
}
